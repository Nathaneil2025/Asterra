name: Nuclear Cleanup - Destroy ALL AWS Resources

on:
  workflow_dispatch:  # Manual trigger only
    inputs:
      confirm_destroy:
        description: 'Type "NUCLEAR" to confirm complete destruction'
        required: true
        default: ''

jobs:
  nuclear-cleanup:
    name: Complete AWS Resource Destruction
    runs-on: ubuntu-latest
    if: github.event.inputs.confirm_destroy == 'NUCLEAR'
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
        
    - name: List all resources before destruction
      run: |
        echo "üîç SCANNING ALL AWS RESOURCES BEFORE DESTRUCTION..."
        echo "=================================================="
        
        echo "=== EC2 INSTANCES ==="
        aws ec2 describe-instances --query 'Reservations[*].Instances[*].[InstanceId,State.Name,Tags[?Key==`Name`].Value|[0],InstanceType]' --output table || echo "No instances"
        
        echo "=== RDS INSTANCES ==="
        aws rds describe-db-instances --query 'DBInstances[*].[DBInstanceIdentifier,DBInstanceStatus,Engine]' --output table || echo "No RDS instances"
        
        echo "=== S3 BUCKETS ==="
        aws s3 ls || echo "No buckets"
        
        echo "=== ECR REPOSITORIES ==="
        aws ecr describe-repositories --query 'repositories[*].[repositoryName,repositoryUri]' --output table || echo "No ECR repos"
        
        echo "=== ECS CLUSTERS ==="
        aws ecs list-clusters --query 'clusterArns' --output table || echo "No ECS clusters"
        
        echo "=== LAMBDA FUNCTIONS ==="
        aws lambda list-functions --query 'Functions[*].[FunctionName,Runtime]' --output table || echo "No Lambda functions"
        
        echo "=== LOAD BALANCERS ==="
        aws elbv2 describe-load-balancers --query 'LoadBalancers[*].[LoadBalancerName,Type,State.Code]' --output table || echo "No ALBs"
        aws elb describe-load-balancers --query 'LoadBalancerDescriptions[*].[LoadBalancerName,Scheme]' --output table || echo "No Classic ELBs"
        
        echo "=== VPCs ==="
        aws ec2 describe-vpcs --query 'Vpcs[*].[VpcId,IsDefault,State,Tags[?Key==`Name`].Value|[0]]' --output table || echo "No VPCs"
        
        echo "=== NAT GATEWAYS ==="
        aws ec2 describe-nat-gateways --query 'NatGateways[*].[NatGatewayId,State,VpcId]' --output table || echo "No NAT Gateways"
        
        echo "=== INTERNET GATEWAYS ==="
        aws ec2 describe-internet-gateways --query 'InternetGateways[*].[InternetGatewayId,Attachments[0].VpcId,Attachments[0].State]' --output table || echo "No IGWs"
        
        echo "=== ELASTIC IPs ==="
        aws ec2 describe-addresses --query 'Addresses[*].[PublicIp,AllocationId,AssociationId,InstanceId]' --output table || echo "No Elastic IPs"
        
        echo "=== SECURITY GROUPS ==="
        aws ec2 describe-security-groups --query 'SecurityGroups[?GroupName!=`default`].[GroupId,GroupName,VpcId]' --output table || echo "No custom security groups"
        
        echo "=== IAM USER GROUPS ==="
        aws iam list-groups --query 'Groups[*].[GroupName,CreateDate]' --output table || echo "No IAM groups"

    - name: 1. Terminate ALL EC2 Instances FIRST
      run: |
        echo "üßπ STEP 1: TERMINATING ALL EC2 INSTANCES FIRST..."
        echo "This must be done first to release dependencies on NAT Gateways and Elastic IPs"
        
        aws ec2 describe-instances --filters "Name=instance-state-name,Values=running,stopped,stopping" --query 'Reservations[*].Instances[*].InstanceId' --output text | tr '\t' '\n' | while read INSTANCE_ID; do
          if [ ! -z "$INSTANCE_ID" ]; then
            echo "Terminating instance: $INSTANCE_ID"
            aws ec2 terminate-instances --instance-ids "$INSTANCE_ID" || echo "Failed to terminate $INSTANCE_ID"
          fi
        done

    - name: 2. Wait for instances to terminate
      run: |
        echo "‚è≥ STEP 2: WAITING FOR ALL INSTANCES TO FULLY TERMINATE..."
        echo "This ensures all dependencies are released before proceeding"
        
        # Get list of instances that need to terminate
        INSTANCE_IDS=$(aws ec2 describe-instances --filters "Name=instance-state-name,Values=running,stopped,stopping,shutting-down" --query 'Reservations[*].Instances[*].InstanceId' --output text)
        
        if [ ! -z "$INSTANCE_IDS" ]; then
          echo "Waiting for instances to terminate: $INSTANCE_IDS"
          echo "This may take several minutes..."
          aws ec2 wait instance-terminated --instance-ids $INSTANCE_IDS || echo "Wait completed or no instances to wait for"
        else
          echo "No instances found to wait for"
        fi
        
        echo "‚úÖ All instances terminated!"

    - name: 3. Release ALL Elastic IPs
      run: |
        echo "üßπ STEP 3: RELEASING ALL ELASTIC IPs..."
        echo "Now that instances are terminated, we can safely release Elastic IPs"
        
        aws ec2 describe-addresses --query 'Addresses[*].[AllocationId,AssociationId,PublicIp]' --output text | while read ALLOCATION_ID ASSOCIATION_ID PUBLIC_IP; do
          if [ ! -z "$ALLOCATION_ID" ]; then
            echo "Processing Elastic IP: $PUBLIC_IP (Allocation: $ALLOCATION_ID)"
            
            # Disassociate if still associated (shouldn't be after instance termination)
            if [ ! -z "$ASSOCIATION_ID" ] && [ "$ASSOCIATION_ID" != "None" ]; then
              echo "  Disassociating from: $ASSOCIATION_ID"
              aws ec2 disassociate-address --association-id "$ASSOCIATION_ID" || echo "  Failed to disassociate"
              sleep 5
            fi
            
            # Release the Elastic IP
            echo "  Releasing Elastic IP: $PUBLIC_IP"
            aws ec2 release-address --allocation-id "$ALLOCATION_ID" || echo "  Failed to release $ALLOCATION_ID"
          fi
        done

    - name: 4. Delete NAT Gateways
      run: |
        echo "üßπ STEP 4: DESTROYING ALL NAT GATEWAYS..."
        echo "Now that instances and Elastic IPs are cleaned up, we can delete NAT Gateways"
        
        aws ec2 describe-nat-gateways --filter "Name=state,Values=available,pending" --query 'NatGateways[*].NatGatewayId' --output text | tr '\t' '\n' | while read NAT_GW_ID; do
          if [ ! -z "$NAT_GW_ID" ]; then
            echo "Deleting NAT Gateway: $NAT_GW_ID"
            aws ec2 delete-nat-gateway --nat-gateway-id "$NAT_GW_ID" || echo "Failed to delete $NAT_GW_ID"
          fi
        done
        
        # Wait for NAT Gateways to be deleted
        echo "Waiting for NAT Gateways to be deleted..."
        sleep 60

    - name: 5. Cleanup Lambda Functions
      run: |
        echo "üßπ STEP 5: DESTROYING ALL LAMBDA FUNCTIONS..."
        aws lambda list-functions --query 'Functions[*].FunctionName' --output text | tr '\t' '\n' | while read FUNC; do
          if [ ! -z "$FUNC" ]; then
            echo "Deleting Lambda function: $FUNC"
            aws lambda delete-function --function-name "$FUNC" || echo "Failed to delete $FUNC"
          fi
        done

    - name: 6. Cleanup ECR Repositories
      run: |
        echo "üßπ STEP 6: DESTROYING ALL ECR REPOSITORIES..."
        aws ecr describe-repositories --query 'repositories[*].repositoryName' --output text | tr '\t' '\n' | while read REPO; do
          if [ ! -z "$REPO" ]; then
            echo "Deleting ECR repository: $REPO"
            aws ecr delete-repository --repository-name "$REPO" --force || echo "Failed to delete $REPO"
          fi
        done

    - name: 7. Cleanup ECS Resources
      run: |
        echo "üßπ STEP 7: DESTROYING ALL ECS RESOURCES..."
        
        # Get all clusters
        aws ecs list-clusters --query 'clusterArns' --output text | tr '\t' '\n' | while read CLUSTER_ARN; do
          if [ ! -z "$CLUSTER_ARN" ]; then
            CLUSTER_NAME=$(basename "$CLUSTER_ARN")
            echo "Processing ECS cluster: $CLUSTER_NAME"
            
            # Stop all services in cluster
            aws ecs list-services --cluster "$CLUSTER_NAME" --query 'serviceArns' --output text | tr '\t' '\n' | while read SERVICE_ARN; do
              if [ ! -z "$SERVICE_ARN" ]; then
                SERVICE_NAME=$(basename "$SERVICE_ARN")
                echo "Stopping service: $SERVICE_NAME"
                aws ecs update-service --cluster "$CLUSTER_NAME" --service "$SERVICE_NAME" --desired-count 0 || echo "Failed to stop $SERVICE_NAME"
                sleep 10
                aws ecs delete-service --cluster "$CLUSTER_NAME" --service "$SERVICE_NAME" || echo "Failed to delete $SERVICE_NAME"
              fi
            done
            
            # Delete cluster
            echo "Deleting cluster: $CLUSTER_NAME"
            aws ecs delete-cluster --cluster "$CLUSTER_NAME" || echo "Failed to delete cluster"
          fi
        done

    - name: 8. Cleanup RDS Resources
      run: |
        echo "üßπ STEP 8: DESTROYING ALL RDS RESOURCES..."
        
        # Delete all DB instances
        aws rds describe-db-instances --query 'DBInstances[*].DBInstanceIdentifier' --output text | tr '\t' '\n' | while read DB; do
          if [ ! -z "$DB" ]; then
            echo "Deleting RDS instance: $DB"
            aws rds delete-db-instance --db-instance-identifier "$DB" --skip-final-snapshot || echo "Failed to delete $DB"
          fi
        done
        
        # Wait for DB instances to start deleting
        sleep 30
        
        # Delete parameter groups
                aws rds describe-db-parameter-groups --query 'DBParameterGroups[?!starts_with(DBParameterGroupName, `default.`)].DBParameterGroupName' --output text | tr '\t' '\n' | while read PG; do
          if [ ! -z "$PG" ]; then
            echo "Deleting parameter group: $PG"
            aws rds delete-db-parameter-group --db-parameter-group-name "$PG" || echo "Failed to delete $PG"
          fi
        done
        
        # Delete subnet groups
        aws rds describe-db-subnet-groups --query 'DBSubnetGroups[?!starts_with(DBSubnetGroupName, `default`)].DBSubnetGroupName' --output text | tr '\t' '\n' | while read SG; do
          if [ ! -z "$SG" ]; then
            echo "Deleting subnet group: $SG"
            aws rds delete-db-subnet-group --db-subnet-group-name "$SG" || echo "Failed to delete $SG"
          fi
        done

    - name: 9. Cleanup Load Balancers and Target Groups
      run: |
        echo "üßπ STEP 9: DESTROYING ALL LOAD BALANCERS AND TARGET GROUPS..."
        
        # Delete Application Load Balancers (ALBs) and Network Load Balancers (NLBs)
        echo "--- Deleting Application/Network Load Balancers ---"
        aws elbv2 describe-load-balancers --query 'LoadBalancers[*].[LoadBalancerArn,LoadBalancerName,Type]' --output text | while read ALB_ARN ALB_NAME ALB_TYPE; do
          if [ ! -z "$ALB_ARN" ]; then
            echo "Deleting $ALB_TYPE Load Balancer: $ALB_NAME ($ALB_ARN)"
            
            # First, delete all listeners
            aws elbv2 describe-listeners --load-balancer-arn "$ALB_ARN" --query 'Listeners[*].ListenerArn' --output text | tr '\t' '\n' | while read LISTENER_ARN; do
              if [ ! -z "$LISTENER_ARN" ]; then
                echo "  Deleting listener: $LISTENER_ARN"
                aws elbv2 delete-listener --listener-arn "$LISTENER_ARN" || echo "  Failed to delete listener"
              fi
            done
            
            # Delete the load balancer
            aws elbv2 delete-load-balancer --load-balancer-arn "$ALB_ARN" || echo "Failed to delete ALB: $ALB_NAME"
            sleep 5
          fi
        done
        
        # Delete Classic Load Balancers (ELBs)
        echo "--- Deleting Classic Load Balancers ---"
        aws elb describe-load-balancers --query 'LoadBalancerDescriptions[*].LoadBalancerName' --output text | tr '\t' '\n' | while read ELB_NAME; do
          if [ ! -z "$ELB_NAME" ]; then
            echo "Deleting Classic ELB: $ELB_NAME"
            aws elb delete-load-balancer --load-balancer-name "$ELB_NAME" || echo "Failed to delete ELB: $ELB_NAME"
            sleep 5
          fi
        done
        
        # Wait for load balancers to be deleted before proceeding with target groups
        echo "--- Waiting for load balancers to be deleted ---"
        sleep 30
        
        # Delete Target Groups (after load balancers are deleted)
        echo "--- Deleting Target Groups ---"
        aws elbv2 describe-target-groups --query 'TargetGroups[*].[TargetGroupArn,TargetGroupName]' --output text | while read TG_ARN TG_NAME; do
          if [ ! -z "$TG_ARN" ]; then
            echo "Deleting Target Group: $TG_NAME ($TG_ARN)"
            aws elbv2 delete-target-group --target-group-arn "$TG_ARN" || echo "Failed to delete Target Group: $TG_NAME"
            sleep 2
          fi
        done

    - name: 10. Cleanup S3 Buckets
      run: |
        echo "üßπ STEP 10: DESTROYING ALL S3 BUCKETS..."
        
        aws s3 ls | awk '{print $3}' | while read BUCKET; do
          if [ ! -z "$BUCKET" ]; then
            echo "Emptying and deleting bucket: $BUCKET"
            
            # Remove all versions and delete markers
            aws s3api list-object-versions --bucket "$BUCKET" --query 'Versions[].{Key:Key,VersionId:VersionId}' --output text | while read KEY VERSION; do
              if [ ! -z "$KEY" ] && [ ! -z "$VERSION" ]; then
                aws s3api delete-object --bucket "$BUCKET" --key "$KEY" --version-id "$VERSION" || echo "Failed to delete version"
              fi
            done
            
            aws s3api list-object-versions --bucket "$BUCKET" --query 'DeleteMarkers[].{Key:Key,VersionId:VersionId}' --output text | while read KEY VERSION; do
              if [ ! -z "$KEY" ] && [ ! -z "$VERSION" ]; then
                aws s3api delete-object --bucket "$BUCKET" --key "$KEY" --version-id "$VERSION" || echo "Failed to delete marker"
              fi
            done
            
            # Empty bucket and delete
            aws s3 rm "s3://$BUCKET" --recursive || echo "Failed to empty $BUCKET"
            aws s3 rb "s3://$BUCKET" || echo "Failed to delete $BUCKET"
          fi
        done

    - name: 11. Delete Security Groups
      run: |
        echo "üßπ STEP 11: DESTROYING ALL CUSTOM SECURITY GROUPS..."
        
        # Get all non-default security groups
        aws ec2 describe-security-groups --query 'SecurityGroups[?GroupName!=`default`].GroupId' --output text | tr '\t' '\n' | while read SG_ID; do
          if [ ! -z "$SG_ID" ]; then
            echo "Attempting to delete security group: $SG_ID"
            
            # Try multiple times as dependencies may need to clear
            for i in {1..5}; do
              if aws ec2 delete-security-group --group-id "$SG_ID" 2>/dev/null; then
                echo "  Successfully deleted: $SG_ID"
                break
              else
                echo "  Attempt $i failed for $SG_ID, retrying in 30 seconds..."
                sleep 30
              fi
            done
          fi
        done

    - name: 12. Detach and Delete Internet Gateways
      run: |
        echo "üßπ STEP 12: DESTROYING ALL INTERNET GATEWAYS..."
        
        aws ec2 describe-internet-gateways --query 'InternetGateways[*].[InternetGatewayId,Attachments[0].VpcId]' --output text | while read IGW_ID VPC_ID; do
          if [ ! -z "$IGW_ID" ] && [ "$VPC_ID" != "None" ] && [ ! -z "$VPC_ID" ]; then
            echo "Detaching IGW $IGW_ID from VPC $VPC_ID"
            aws ec2 detach-internet-gateway --internet-gateway-id "$IGW_ID" --vpc-id "$VPC_ID" || echo "Failed to detach $IGW_ID"
            sleep 10
            
            echo "Deleting IGW: $IGW_ID"
            aws ec2 delete-internet-gateway --internet-gateway-id "$IGW_ID" || echo "Failed to delete $IGW_ID"
          fi
        done

    - name: 13. Delete Subnets
      run: |
        echo "üßπ STEP 13: DESTROYING ALL SUBNETS..."
        
        aws ec2 describe-subnets --query 'Subnets[*].SubnetId' --output text | tr '\t' '\n' | while read SUBNET_ID; do
          if [ ! -z "$SUBNET_ID" ]; then
            echo "Deleting subnet: $SUBNET_ID"
            aws ec2 delete-subnet --subnet-id "$SUBNET_ID" || echo "Failed to delete $SUBNET_ID"
          fi
        done

    - name: 14. Delete Route Tables
      run: |
        echo "üßπ STEP 14: DESTROYING ALL CUSTOM ROUTE TABLES..."
        
        # Get all route tables that are not main route tables
        aws ec2 describe-route-tables --query 'RouteTables[?Associations[0].Main!=`true`].RouteTableId' --output text | tr '\t' '\n' | while read RT_ID; do
          if [ ! -z "$RT_ID" ]; then
            echo "Deleting route table: $RT_ID"
            aws ec2 delete-route-table --route-table-id "$RT_ID" || echo "Failed to delete $RT_ID"
          fi
        done

    - name: 15. Delete VPCs
      run: |
        echo "üßπ STEP 15: DESTROYING ALL NON-DEFAULT VPCs..."
        
        aws ec2 describe-vpcs --query 'Vpcs[?IsDefault!=`true`].VpcId' --output text | tr '\t' '\n' | while read VPC_ID; do
          if [ ! -z "$VPC_ID" ]; then
            echo "Deleting VPC: $VPC_ID"
            aws ec2 delete-vpc --vpc-id "$VPC_ID" || echo "Failed to delete $VPC_ID"
          fi
        done

    - name: 16. Cleanup CloudWatch Log Groups
      run: |
        echo "üßπ STEP 16: DESTROYING ALL CLOUDWATCH LOG GROUPS..."
        
        aws logs describe-log-groups --query 'logGroups[*].logGroupName' --output text | tr '\t' '\n' | while read LOG_GROUP; do
          if [ ! -z "$LOG_GROUP" ]; then
            echo "Deleting log group: $LOG_GROUP"
            aws logs delete-log-group --log-group-name "$LOG_GROUP" || echo "Failed to delete $LOG_GROUP"
          fi
        done

    - name: 17. Cleanup IAM User Groups
      run: |
        echo "üßπ STEP 17: DESTROYING ALL IAM USER GROUPS..."
        
        # Get all IAM groups
        aws iam list-groups --query 'Groups[*].GroupName' --output text | tr '\t' '\n' | while read GROUP_NAME; do
          if [ ! -z "$GROUP_NAME" ]; then
            echo "Processing IAM group: $GROUP_NAME"
            
            # Remove all users from the group
            aws iam get-group --group-name "$GROUP_NAME" --query 'Users[*].UserName' --output text | tr '\t' '\n' | while read USER_NAME; do
              if [ ! -z "$USER_NAME" ]; then
                echo "  Removing user $USER_NAME from group $GROUP_NAME"
                aws iam remove-user-from-group --group-name "$GROUP_NAME" --user-name "$USER_NAME" || echo "  Failed to remove user $USER_NAME"
              fi
            done
            
            # Detach all managed policies from the group
                        aws iam list-attached-group-policies --group-name "$GROUP_NAME" --query 'AttachedPolicies[*].PolicyArn' --output text | tr '\t' '\n' | while read POLICY_ARN; do
              if [ ! -z "$POLICY_ARN" ]; then
                echo "  Detaching managed policy $POLICY_ARN from group $GROUP_NAME"
                aws iam detach-group-policy --group-name "$GROUP_NAME" --policy-arn "$POLICY_ARN" || echo "  Failed to detach policy $POLICY_ARN"
              fi
            done
            
            # Delete all inline policies from the group
            aws iam list-group-policies --group-name "$GROUP_NAME" --query 'PolicyNames' --output text | tr '\t' '\n' | while read POLICY_NAME; do
              if [ ! -z "$POLICY_NAME" ]; then
                echo "  Deleting inline policy $POLICY_NAME from group $GROUP_NAME"
                aws iam delete-group-policy --group-name "$GROUP_NAME" --policy-name "$POLICY_NAME" || echo "  Failed to delete inline policy $POLICY_NAME"
              fi
            done
            
            # Delete the group
            echo "  Deleting IAM group: $GROUP_NAME"
            aws iam delete-group --group-name "$GROUP_NAME" || echo "  Failed to delete group $GROUP_NAME"
          fi
        done

    - name: 18. Cleanup IAM Roles
      run: |
        echo "üßπ STEP 18: DESTROYING ALL CUSTOM IAM ROLES..."
        
        # Get all IAM roles (excluding AWS service roles)
        aws iam list-roles --query 'Roles[?!starts_with(RoleName, `AWS`) && !starts_with(RoleName, `aws-`) && !starts_with(RoleName, `service-role`)].RoleName' --output text | tr '\t' '\n' | while read ROLE_NAME; do
          if [ ! -z "$ROLE_NAME" ]; then
            echo "Processing IAM role: $ROLE_NAME"
            
            # Detach all managed policies from the role
            aws iam list-attached-role-policies --role-name "$ROLE_NAME" --query 'AttachedPolicies[*].PolicyArn' --output text | tr '\t' '\n' | while read POLICY_ARN; do
              if [ ! -z "$POLICY_ARN" ]; then
                echo "  Detaching managed policy $POLICY_ARN from role $ROLE_NAME"
                aws iam detach-role-policy --role-name "$ROLE_NAME" --policy-arn "$POLICY_ARN" || echo "  Failed to detach policy $POLICY_ARN"
              fi
            done
            
            # Delete all inline policies from the role
            aws iam list-role-policies --role-name "$ROLE_NAME" --query 'PolicyNames' --output text | tr '\t' '\n' | while read POLICY_NAME; do
              if [ ! -z "$POLICY_NAME" ]; then
                echo "  Deleting inline policy $POLICY_NAME from role $ROLE_NAME"
                aws iam delete-role-policy --role-name "$ROLE_NAME" --policy-name "$POLICY_NAME" || echo "  Failed to delete inline policy $POLICY_NAME"
              fi
            done
            
            # Remove role from instance profiles
            aws iam list-instance-profiles-for-role --role-name "$ROLE_NAME" --query 'InstanceProfiles[*].InstanceProfileName' --output text | tr '\t' '\n' | while read PROFILE_NAME; do
              if [ ! -z "$PROFILE_NAME" ]; then
                echo "  Removing role $ROLE_NAME from instance profile $PROFILE_NAME"
                aws iam remove-role-from-instance-profile --instance-profile-name "$PROFILE_NAME" --role-name "$ROLE_NAME" || echo "  Failed to remove role from profile"
              fi
            done
            
            # Delete the role
            echo "  Deleting IAM role: $ROLE_NAME"
            aws iam delete-role --role-name "$ROLE_NAME" || echo "  Failed to delete role $ROLE_NAME"
          fi
        done

    - name: 19. Cleanup IAM Policies
      run: |
        echo "üßπ STEP 19: DESTROYING ALL CUSTOM IAM POLICIES..."
        
        # Get all customer managed policies (not AWS managed)
        aws iam list-policies --scope Local --query 'Policies[*].[PolicyName,Arn]' --output text | while read POLICY_NAME POLICY_ARN; do
          if [ ! -z "$POLICY_ARN" ]; then
            echo "Processing custom IAM policy: $POLICY_NAME ($POLICY_ARN)"
            
            # Get all policy versions
            aws iam list-policy-versions --policy-arn "$POLICY_ARN" --query 'Versions[?!IsDefaultVersion].VersionId' --output text | tr '\t' '\n' | while read VERSION_ID; do
              if [ ! -z "$VERSION_ID" ]; then
                echo "  Deleting policy version: $VERSION_ID"
                aws iam delete-policy-version --policy-arn "$POLICY_ARN" --version-id "$VERSION_ID" || echo "  Failed to delete version $VERSION_ID"
              fi
            done
            
            # Delete the policy
            echo "  Deleting IAM policy: $POLICY_NAME"
            aws iam delete-policy --policy-arn "$POLICY_ARN" || echo "  Failed to delete policy $POLICY_NAME"
          fi
        done

    - name: 20. Cleanup IAM Instance Profiles
      run: |
        echo "üßπ STEP 20: DESTROYING ALL IAM INSTANCE PROFILES..."
        
        aws iam list-instance-profiles --query 'InstanceProfiles[*].InstanceProfileName' --output text | tr '\t' '\n' | while read PROFILE_NAME; do
          if [ ! -z "$PROFILE_NAME" ]; then
            echo "Deleting instance profile: $PROFILE_NAME"
            aws iam delete-instance-profile --instance-profile-name "$PROFILE_NAME" || echo "Failed to delete instance profile $PROFILE_NAME"
          fi
        done

    - name: 21. Cleanup DynamoDB Tables
      run: |
        echo "üßπ STEP 21: DESTROYING ALL DYNAMODB TABLES..."
        
        aws dynamodb list-tables --query 'TableNames' --output text | tr '\t' '\n' | while read TABLE_NAME; do
          if [ ! -z "$TABLE_NAME" ]; then
            echo "Deleting DynamoDB table: $TABLE_NAME"
            aws dynamodb delete-table --table-name "$TABLE_NAME" || echo "Failed to delete table $TABLE_NAME"
          fi
        done

    - name: 22. Cleanup API Gateway APIs
      run: |
        echo "üßπ STEP 22: DESTROYING ALL API GATEWAY APIs..."
        
        # REST APIs
        aws apigateway get-rest-apis --query 'items[*].[id,name]' --output text | while read API_ID API_NAME; do
          if [ ! -z "$API_ID" ]; then
            echo "Deleting REST API: $API_NAME ($API_ID)"
            aws apigateway delete-rest-api --rest-api-id "$API_ID" || echo "Failed to delete REST API $API_ID"
          fi
        done
        
        # HTTP APIs (API Gateway v2)
        aws apigatewayv2 get-apis --query 'Items[*].[ApiId,Name]' --output text | while read API_ID API_NAME; do
          if [ ! -z "$API_ID" ]; then
            echo "Deleting HTTP API: $API_NAME ($API_ID)"
            aws apigatewayv2 delete-api --api-id "$API_ID" || echo "Failed to delete HTTP API $API_ID"
          fi
        done

    - name: 23. Final Verification
      run: |
        echo "üîç FINAL VERIFICATION - SCANNING FOR REMAINING RESOURCES..."
        echo "============================================================"
        
        echo "=== REMAINING EC2 INSTANCES ==="
        INSTANCES=$(aws ec2 describe-instances --filters "Name=instance-state-name,Values=running,stopped,stopping" --query 'Reservations[*].Instances[*].InstanceId' --output text)
        if [ -z "$INSTANCES" ]; then
          echo "‚úÖ No EC2 instances remaining"
        else
          echo "‚ö†Ô∏è Remaining instances: $INSTANCES"
        fi
        
        echo "=== REMAINING RDS INSTANCES ==="
        RDS_INSTANCES=$(aws rds describe-db-instances --query 'DBInstances[*].DBInstanceIdentifier' --output text)
        if [ -z "$RDS_INSTANCES" ]; then
          echo "‚úÖ No RDS instances remaining"
        else
          echo "‚ö†Ô∏è Remaining RDS instances: $RDS_INSTANCES"
        fi
        
        echo "=== REMAINING S3 BUCKETS ==="
        BUCKETS=$(aws s3 ls | awk '{print $3}' | tr '\n' ' ')
        if [ -z "$BUCKETS" ]; then
          echo "‚úÖ No S3 buckets remaining"
        else
          echo "‚ö†Ô∏è Remaining buckets: $BUCKETS"
        fi
        
        echo "=== REMAINING ECR REPOSITORIES ==="
        ECR_REPOS=$(aws ecr describe-repositories --query 'repositories[*].repositoryName' --output text)
        if [ -z "$ECR_REPOS" ]; then
          echo "‚úÖ No ECR repositories remaining"
        else
          echo "‚ö†Ô∏è Remaining ECR repos: $ECR_REPOS"
        fi
        
        echo "=== REMAINING ECS CLUSTERS ==="
        ECS_CLUSTERS=$(aws ecs list-clusters --query 'clusterArns' --output text)
        if [ -z "$ECS_CLUSTERS" ]; then
          echo "‚úÖ No ECS clusters remaining"
        else
          echo "‚ö†Ô∏è Remaining ECS clusters: $ECS_CLUSTERS"
        fi
        
        echo "=== REMAINING LAMBDA FUNCTIONS ==="
        LAMBDA_FUNCS=$(aws lambda list-functions --query 'Functions[*].FunctionName' --output text)
        if [ -z "$LAMBDA_FUNCS" ]; then
          echo "‚úÖ No Lambda functions remaining"
        else
          echo "‚ö†Ô∏è Remaining Lambda functions: $LAMBDA_FUNCS"
        fi
        
        echo ""
        echo "üéØ NUCLEAR CLEANUP COMPLETED!"
        echo "============================================"
        echo "All AWS resources have been processed for deletion."
        echo "Some resources may take additional time to fully terminate."
        echo "Please check the AWS Console to verify complete cleanup."