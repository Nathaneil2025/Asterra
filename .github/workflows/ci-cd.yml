name: CI/CD Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  AWS_REGION: eu-central-1
  ECR_REPOSITORY: geojson-processor
  ECS_CLUSTER: geojson-processor-cluster
  ECS_SERVICE: geojson-processor-service
  WORDPRESS_SERVICE: wordpress-service

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
        
    - name: Install dependencies
      run: |
        cd geojson-processor
        pip install -r requirements.txt
        pip install pytest pytest-cov
        
    - name: Run tests
      run: |
        cd geojson-processor
        pytest tests/ --cov=. --cov-report=xml || echo "Tests completed with warnings"
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: './geojson-processor'
        format: 'table'
      continue-on-error: true

  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.12.2
        terraform_wrapper: false
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Check Remote State Setup
      run: |
        echo "🔍 Checking remote state setup for PR..."
        
        # Check if S3 bucket exists
        if aws s3 ls s3://terraform-state-asterra-project/ > /dev/null 2>&1; then
          echo "✅ S3 bucket exists"
          S3_EXISTS=true
        else
          echo "⚠️ S3 bucket not found - this is expected for first-time setup"
          S3_EXISTS=false
        fi
        
        # Check if DynamoDB table exists
        if aws dynamodb describe-table --table-name terraform-state-lock --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
          echo "✅ DynamoDB lock table exists"
          DYNAMO_EXISTS=true
        else
          echo "⚠️ DynamoDB lock table not found - this is expected for first-time setup"
          DYNAMO_EXISTS=false
        fi
        
        # If remote state doesn't exist, we'll use local state for planning
        if [ "$S3_EXISTS" = false ] || [ "$DYNAMO_EXISTS" = false ]; then
          echo "📝 Remote state not available - will use local state for planning"
          echo "   (Remote state will be automatically created when merging to main)"
          
          # Temporarily rename backend.tf to disable remote state for planning
          if [ -f "backend.tf" ]; then
            mv backend.tf backend.tf.disabled
            echo "   Temporarily disabled remote backend for PR planning"
          fi
        fi
        
    - name: Terraform Init
      run: terraform init
      
    - name: Terraform Validate
      run: terraform validate
      
    - name: Terraform Plan
      id: plan
      run: terraform plan -no-color
      continue-on-error: true
      
    - name: Restore Backend Configuration
      if: always()
      run: |
        # Restore backend.tf if it was disabled
        if [ -f "backend.tf.disabled" ]; then
          mv backend.tf.disabled backend.tf
          echo "✅ Restored backend configuration"
        fi
      
    - name: Comment PR
      uses: actions/github-script@v7
      if: github.event_name == 'pull_request'
      with:
        script: |
          const output = `#### Terraform Plan 📖
          
          <details><summary>Show Plan</summary>
          
          \`\`\`terraform
          ${{ steps.plan.outputs.stdout }}
          \`\`\`
          
          </details>
          
          *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*
          
          > **Note**: If this is the first deployment, remote state infrastructure will be automatically created when this PR is merged to main.`;
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: output
          })
  terraform-apply:
    name: Terraform Apply
    needs: [test, security-scan]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    outputs:
      wordpress_url: ${{ steps.terraform-output.outputs.wordpress_url }}
      ecr_repository_url: ${{ steps.terraform-output.outputs.ecr_repository_url }}
      infrastructure_changed: ${{ steps.terraform-apply.outputs.changed }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.12.2
        terraform_wrapper: false
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Verify AWS Permissions
      run: |
        echo "🔐 Verifying AWS permissions..."
        
        # Check basic AWS access
        echo "👤 Current AWS identity:"
        aws sts get-caller-identity
        
        # Check specific permissions we need
        echo "🔍 Testing required AWS permissions..."
        
        # Test S3 permissions
        echo "📦 Testing S3 access..."
        aws s3 ls > /dev/null && echo "✅ S3 list access confirmed" || echo "⚠️ S3 access issues"
        
        # Test ECR permissions
        echo "🐳 Testing ECR access..."
        aws ecr describe-repositories --max-items 1 > /dev/null && echo "✅ ECR access confirmed" || echo "⚠️ ECR access issues"
        
        # Test ECS permissions
        echo "🚢 Testing ECS access..."
        aws ecs list-clusters --max-items 1 > /dev/null && echo "✅ ECS access confirmed" || echo "⚠️ ECS access issues"
        
        # Test RDS permissions
        echo "🗄️ Testing RDS access..."
        aws rds describe-db-instances --max-items 1 > /dev/null && echo "✅ RDS access confirmed" || echo "⚠️ RDS access issues"
        
        # Test IAM permissions
        echo "👥 Testing IAM access..."
        aws iam list-roles --max-items 1 > /dev/null && echo "✅ IAM access confirmed" || echo "⚠️ IAM access issues"
        
        echo "✅ Permission check completed"
        
    - name: Setup State Infrastructure
      run: |
        echo "🔍 Checking if state infrastructure exists..."
        
        # Check if both S3 bucket and DynamoDB table exist
        if aws s3 ls s3://terraform-state-asterra-project/ > /dev/null 2>&1 && \
           aws dynamodb describe-table --table-name terraform-state-lock --region eu-central-1 > /dev/null 2>&1; then
          echo "✅ State infrastructure exists - skipping creation"
          
          # Ensure state-setup.tf is disabled
          if [ -f "state-setup.tf" ]; then
            mv state-setup.tf state-setup.tf.disabled
            echo "✅ Disabled state-setup.tf to prevent conflicts"
          fi
        else
          echo "🏗️ Creating state infrastructure..."
          
          # Ensure state-setup.tf is enabled
          if [ -f "state-setup.tf.disabled" ]; then
            mv state-setup.tf.disabled state-setup.tf
            echo "✅ Enabled state-setup.tf for bootstrapping"
          fi
          
          # Temporarily rename backend.tf to avoid conflicts
          if [ -f "backend.tf" ]; then
            mv backend.tf backend.tf.temp
            echo "✅ Temporarily disabled backend configuration"
          fi
          
          # Initialize and create state infrastructure with local state
          terraform init
          terraform plan -out=state-plan
          terraform apply state-plan
          
          # Restore backend.tf and disable state-setup.tf
          if [ -f "backend.tf.temp" ]; then
            mv backend.tf.temp backend.tf
            echo "✅ Restored backend configuration"
          fi
          
          if [ -f "state-setup.tf" ]; then
            mv state-setup.tf state-setup.tf.disabled
            echo "✅ Disabled state-setup.tf after creation"
          fi
          
          echo "✅ State infrastructure created successfully"
        fi

    - name: Deploy Application Infrastructure
      run: |
        echo "🚀 Deploying application infrastructure..."
        
        # Ensure state-setup.tf is disabled
        if [ -f "state-setup.tf" ]; then
          mv state-setup.tf state-setup.tf.disabled
          echo "✅ Disabled state-setup.tf to prevent conflicts"
        fi
        
        # Initialize with automatic approval for state migration
        echo "🔧 Initializing Terraform with remote backend..."
        echo "yes" | terraform init -input=false -no-color
        
        echo "📋 Creating Terraform plan..."
        terraform plan -input=false -no-color
        
        echo "🚀 Applying Terraform configuration..."
        terraform apply -auto-approve -input=false -no-color
        
        echo "✅ Application infrastructure deployment complete

    - name: Remove State Resources from Terraform Management
      run: |
        echo "🧹 Ensuring state infrastructure is not managed by main configuration..."
        
        # Disable state-setup.tf if it exists
        if [ -f "state-setup.tf" ]; then
          mv state-setup.tf state-setup.tf.disabled
          echo "✅ Disabled state-setup.tf to prevent conflicts"
        fi
        
        echo "✅ State infrastructure removed from main configuration management"

    - name: Terraform Init
      run: |
        echo "🔧 Initializing Terraform with remote backend..."
        terraform init -no-color
        echo "✅ Terraform initialization complete"
        
        # Remove any state resources that might be in the state file
        echo "🧹 Cleaning up any state resources from Terraform state..."
        terraform state rm aws_s3_bucket.terraform_state 2>/dev/null || echo "S3 bucket not in state"
        terraform state rm aws_dynamodb_table.terraform_state_lock 2>/dev/null || echo "DynamoDB table not in state"
        terraform state rm aws_s3_bucket_versioning.terraform_state 2>/dev/null || echo "S3 versioning not in state"
        terraform state rm aws_s3_bucket_server_side_encryption_configuration.terraform_state 2>/dev/null || echo "S3 encryption not in state"
        terraform state rm aws_s3_bucket_public_access_block.terraform_state 2>/dev/null || echo "S3 public access block not in state"
        
        echo "✅ Terraform initialization complete"
      
    - name: Terraform Validate
      run: |
        echo "✅ Validating Terraform configuration..."
        terraform validate -no-color
      
    - name: Terraform Plan
      run: |
        echo "📋 Creating Terraform plan..."
        
        # Create plan with detailed output
        terraform plan -out=tfplan -detailed-exitcode -no-color 2>&1 | tee plan_output.log
        PLAN_EXIT_CODE=${PIPESTATUS[0]}
        
        echo "📊 Plan completed with exit code: $PLAN_EXIT_CODE"
        
        if [ $PLAN_EXIT_CODE -eq 0 ]; then
          echo "✅ No changes needed"
        elif [ $PLAN_EXIT_CODE -eq 2 ]; then
          echo "✅ Plan created with changes to apply"
        fi
      
    - name: Terraform Apply
      id: terraform-apply
      run: |
        echo "🚀 Applying Terraform configuration..."
        
        # Apply with real-time output and capture exit code
        set +e  # Don't exit on error so we can handle it
        terraform apply tfplan
        APPLY_EXIT_CODE=$?
        set -e  # Re-enable exit on error
        
        echo "📊 Apply completed with exit code: $APPLY_EXIT_CODE"
        
        if [ $APPLY_EXIT_CODE -eq 0 ]; then
          echo "✅ Terraform apply completed successfully"
          echo "changed=true" >> $GITHUB_OUTPUT
        else
          echo "❌ Terraform apply failed with exit code $APPLY_EXIT_CODE"
          echo "🔍 Checking for common issues..."
          
          # Try to get more information about the failure
          echo "📋 Terraform state list:"
          terraform state list || echo "Could not list state"
          
          echo "📊 Terraform show (current state):"
          terraform show || echo "Could not show current state"
          
          echo "changed=false" >> $GITHUB_OUTPUT
          exit $APPLY_EXIT_CODE
        fi
      
    - name: Get Terraform Outputs
      id: terraform-output
      run: |
        echo "📤 Retrieving Terraform outputs..."
        WORDPRESS_URL=$(terraform output -raw wordpress_url 2>/dev/null || echo 'not-available')
        ECR_URL=$(terraform output -raw ecr_repository_url 2>/dev/null || echo 'not-available')
        
        echo "wordpress_url=$WORDPRESS_URL" >> $GITHUB_OUTPUT
        echo "ecr_repository_url=$ECR_URL" >> $GITHUB_OUTPUT
        
        echo "WordPress URL: $WORDPRESS_URL"
        echo "ECR Repository URL: $ECR_URL"
  build-and-deploy:
    name: Build and Deploy GeoJSON Processor
    needs: [terraform-apply]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Check ECR Repository
      run: |
        echo "🔍 Checking ECR repository..."
        ECR_URL="${{ needs.terraform-apply.outputs.ecr_repository_url }}"
        
        if [ "$ECR_URL" = "not-available" ]; then
          echo "⚠️ ECR repository URL not available from Terraform outputs"
          # Try to get it directly from AWS
          ECR_URL=$(aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} --query 'repositories[0].repositoryUri' --output text 2>/dev/null || echo "")
          
          if [ -z "$ECR_URL" ]; then
            echo "❌ Could not find ECR repository. Skipping build and deploy."
            exit 0
                    else
            echo "✅ Found ECR repository: $ECR_URL"
          fi
        else
          echo "✅ ECR repository URL available: $ECR_URL"
        fi
        
        # Export for use in subsequent steps
        echo "ECR_REPOSITORY_URL=$ECR_URL" >> $GITHUB_ENV
        
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
      
    - name: Get version
      id: version
      run: |
        VERSION=$(git rev-parse --short HEAD)
        echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
        echo "IMAGE_TAG=$ECR_REPOSITORY_URL:$VERSION" >> $GITHUB_OUTPUT
        
    - name: Build Docker image
      run: |
        echo "🔨 Building Docker image..."
        cd geojson-processor
        docker build -t ${{ steps.version.outputs.IMAGE_TAG }} .
        docker tag ${{ steps.version.outputs.IMAGE_TAG }} $ECR_REPOSITORY_URL:latest
        
    - name: Push image to ECR
      run: |
        echo "📤 Pushing image to ECR..."
        docker push ${{ steps.version.outputs.IMAGE_TAG }}
        docker push $ECR_REPOSITORY_URL:latest
        echo "✅ Image pushed successfully"
        
    - name: Check ECS Service Exists
      id: check-service
      run: |
        echo "🔍 Checking if ECS service exists..."
        if aws ecs describe-services \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE }} \
          --query 'services[0].serviceName' \
          --output text 2>/dev/null | grep -q "${{ env.ECS_SERVICE }}"; then
          echo "✅ ECS service exists"
          echo "service_exists=true" >> $GITHUB_OUTPUT
        else
          echo "⚠️ ECS service does not exist yet - skipping deployment"
          echo "service_exists=false" >> $GITHUB_OUTPUT
        fi
        
    - name: Get current task definition
      id: current-task-def
      if: steps.check-service.outputs.service_exists == 'true'
      run: |
        echo "📋 Getting current task definition..."
        # Get the current task definition
        TASK_DEF_ARN=$(aws ecs describe-services \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE }} \
          --query 'services[0].taskDefinition' \
          --output text)
          
        aws ecs describe-task-definition \
          --task-definition $TASK_DEF_ARN \
          --query 'taskDefinition' \
          --output json > current-task-def.json
        
    - name: Update task definition with new image
      if: steps.check-service.outputs.service_exists == 'true'
      run: |
        echo "🔄 Updating task definition with new image..."
        # Update the image in the task definition
        jq --arg IMAGE "${{ steps.version.outputs.IMAGE_TAG }}" \
           '.containerDefinitions[0].image = $IMAGE' \
           current-task-def.json > updated-task-def.json
           
        # Remove fields that shouldn't be in registration
        jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)' \
           updated-task-def.json > final-task-def.json
        
    - name: Register new task definition
      id: register-task-def
      if: steps.check-service.outputs.service_exists == 'true'
      run: |
        echo "📝 Registering new task definition..."
        NEW_TASK_DEF=$(aws ecs register-task-definition \
          --cli-input-json file://final-task-def.json \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)
        echo "NEW_TASK_DEF_ARN=$NEW_TASK_DEF" >> $GITHUB_OUTPUT
        echo "✅ New task definition registered: $NEW_TASK_DEF"
        
    - name: Deploy to ECS
      if: steps.check-service.outputs.service_exists == 'true'
      run: |
        echo "🚀 Deploying to ECS..."
        aws ecs update-service \
          --cluster ${{ env.ECS_CLUSTER }} \
          --service ${{ env.ECS_SERVICE }} \
          --task-definition ${{ steps.register-task-def.outputs.NEW_TASK_DEF_ARN }}
          
        echo "⏳ Waiting for service to stabilize..."
        aws ecs wait services-stable \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE }} \
          --max-attempts 10 \
          --delay 30 || {
          echo "⚠️ Service did not stabilize within timeout, but continuing..."
        }
        echo "✅ Service deployment completed"
  deploy-wordpress:
    name: Deploy WordPress
    needs: [terraform-apply]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Check WordPress Service Exists
      id: check-wordpress
      run: |
        echo "🔍 Checking if WordPress service exists..."
        if aws ecs describe-services \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.WORDPRESS_SERVICE }} \
          --query 'services[0].serviceName' \
          --output text 2>/dev/null | grep -q "${{ env.WORDPRESS_SERVICE }}"; then
          echo "✅ WordPress service exists"
          echo "service_exists=true" >> $GITHUB_OUTPUT
        else
          echo "⚠️ WordPress service does not exist yet - skipping deployment"
          echo "service_exists=false" >> $GITHUB_OUTPUT
        fi
        
    - name: Force WordPress service update
      if: steps.check-wordpress.outputs.service_exists == 'true'
      run: |
        echo "🔄 Forcing WordPress service update..."
        aws ecs update-service \
          --cluster ${{ env.ECS_CLUSTER }} \
          --service ${{ env.WORDPRESS_SERVICE }} \
          --force-new-deployment
          
    - name: Wait for WordPress deployment
      if: steps.check-wordpress.outputs.service_exists == 'true'
      run: |
        echo "⏳ Waiting for WordPress service to stabilize..."
        aws ecs wait services-stable \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.WORDPRESS_SERVICE }} \
          --max-attempts 10 \
          --delay 30 || {
          echo "⚠️ WordPress service did not stabilize within timeout, but continuing..."
        }
        echo "✅ WordPress deployment completed"
  health-check:
    name: Health Check
    needs: [deploy-wordpress, build-and-deploy]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && always()
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Check GeoJSON Processor health
      run: |
        echo "🔍 Checking GeoJSON Processor service..."
        
        # Check if service exists first
        if aws ecs describe-services \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE }} \
          --query 'services[0].serviceName' \
          --output text 2>/dev/null | grep -q "${{ env.ECS_SERVICE }}"; then
          
          SERVICE_STATUS=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --query 'services[0].status' \
            --output text)
            
          RUNNING_COUNT=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --query 'services[0].runningCount' \
            --output text)
            
          DESIRED_COUNT=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --query 'services[0].desiredCount' \
            --output text)
          
          echo "Service Status: $SERVICE_STATUS"
          echo "Running Tasks: $RUNNING_COUNT"
          echo "Desired Tasks: $DESIRED_COUNT"
          
          if [ "$SERVICE_STATUS" = "ACTIVE" ]; then
            echo "✅ GeoJSON Processor service is active"
          else
            echo "⚠️ GeoJSON Processor service status: $SERVICE_STATUS"
          fi
        else
          echo "⚠️ GeoJSON Processor service does not exist yet"
        fi
        
    - name: Check WordPress health
      run: |
        echo "🔍 Checking WordPress service..."
        
        # Check if service exists first
        if aws ecs describe-services \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.WORDPRESS_SERVICE }} \
          --query 'services[0].serviceName' \
          --output text 2>/dev/null | grep -q "${{ env.WORDPRESS_SERVICE }}"; then
          
          SERVICE_STATUS=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.WORDPRESS_SERVICE }} \
            --query 'services[0].status' \
            --output text)
            
          RUNNING_COUNT=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.WORDPRESS_SERVICE }} \
            --query 'services[0].runningCount' \
            --output text)
            
          DESIRED_COUNT=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.WORDPRESS_SERVICE }} \
            --query 'services[0].desiredCount' \
            --output text)
          
          echo "Service Status: $SERVICE_STATUS"
          echo "Running Tasks: $RUNNING_COUNT"
          echo "Desired Tasks: $DESIRED_COUNT"
          
          if [ "$SERVICE_STATUS" = "ACTIVE" ] && [ "$RUNNING_COUNT" -eq "$DESIRED_COUNT" ] && [ "$RUNNING_COUNT" -gt 0 ]; then
            echo "✅ WordPress service is healthy"
          else
            echo "⚠️ WordPress service health check: Status=$SERVICE_STATUS, Running=$RUNNING_COUNT, Desired=$DESIRED_COUNT"
          fi
        else
          echo "⚠️ WordPress service does not exist yet"
        fi
        
    - name: Test Application Endpoints
      run: |
        echo "🔍 Testing application endpoints..."
        
        # Get WordPress URL if available
        WORDPRESS_URL="${{ needs.terraform-apply.outputs.wordpress_url }}"
        
        if [ "$WORDPRESS_URL" != "not-available" ] && [ -n "$WORDPRESS_URL" ]; then
          echo "Testing WordPress endpoint: $WORDPRESS_URL"
          
          # Test WordPress health with timeout
          if curl -f -s --max-time 30 "$WORDPRESS_URL" > /dev/null; then
            echo "✅ WordPress is responding"
          else
            echo "⚠️ WordPress endpoint not responding (this is normal for new deployments)"
          fi
        else
          echo "⚠️ WordPress URL not available for testing"
        fi
        
        # Test if we can reach AWS services
        echo "Testing AWS connectivity..."
        if aws sts get-caller-identity > /dev/null 2>&1; then
          echo "✅ AWS connectivity confirmed"
        else
          echo "❌ AWS connectivity failed"
        fi
  deployment-summary:
    name: Deployment Summary
    needs: [terraform-apply, build-and-deploy, deploy-wordpress, health-check]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && always()
    
    steps:
    - name: Generate Deployment Summary
      run: |
        echo "# 🚀 Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Infrastructure Status
        echo "## 🏗️ Infrastructure" >> $GITHUB_STEP_SUMMARY
        if [ "${{ needs.terraform-apply.result }}" = "success" ]; then
          echo "✅ **Terraform Apply**: Successful" >> $GITHUB_STEP_SUMMARY
        else
          echo "❌ **Terraform Apply**: Failed" >> $GITHUB_STEP_SUMMARY
        fi
        
        # Application Deployment Status
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## 📦 Application Deployments" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ needs.build-and-deploy.result }}" = "success" ]; then
          echo "✅ **GeoJSON Processor**: Deployed successfully" >> $GITHUB_STEP_SUMMARY
        elif [ "${{ needs.build-and-deploy.result }}" = "skipped" ]; then
          echo "⏭️ **GeoJSON Processor**: Skipped (no changes or service not ready)" >> $GITHUB_STEP_SUMMARY
        else
          echo "❌ **GeoJSON Processor**: Deployment failed" >> $GITHUB_STEP_SUMMARY
        fi
        
        if [ "${{ needs.deploy-wordpress.result }}" = "success" ]; then
          echo "✅ **WordPress**: Deployed successfully" >> $GITHUB_STEP_SUMMARY
        elif [ "${{ needs.deploy-wordpress.result }}" = "skipped" ]; then
          echo "⏭️ **WordPress**: Skipped (service not ready)" >> $GITHUB_STEP_SUMMARY
        else
          echo "❌ **WordPress**: Deployment failed" >> $GITHUB_STEP_SUMMARY
        fi
        
        # Health Check Status
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## 🔍 Health Checks" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ needs.health-check.result }}" = "success" ]; then
          echo "✅ **Health Checks**: All services checked" >> $GITHUB_STEP_SUMMARY
        else
          echo "⚠️ **Health Checks**: Some issues detected" >> $GITHUB_STEP_SUMMARY
        fi
        
        # Access Information
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## 🌐 Access Information" >> $GITHUB_STEP_SUMMARY
        
        WORDPRESS_URL="${{ needs.terraform-apply.outputs.wordpress_url }}"
        if [ "$WORDPRESS_URL" != "not-available" ] && [ -n "$WORDPRESS_URL" ]; then
          echo "🔗 **WordPress URL**: [$WORDPRESS_URL]($WORDPRESS_URL)" >> $GITHUB_STEP_SUMMARY
        else
          echo "⏳ **WordPress URL**: Will be available after first successful deployment" >> $GITHUB_STEP_SUMMARY
        fi
        
        # Next Steps
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## 📋 Next Steps" >> $GITHUB_STEP_SUMMARY
        echo "- Monitor the ECS services in the AWS Console" >> $GITHUB_STEP_SUMMARY
        echo "- Check CloudWatch logs for any issues" >> $GITHUB_STEP_SUMMARY
        echo "- Test the GeoJSON processor by uploading files to the S3 bucket" >> $GITHUB_STEP_SUMMARY
        echo "- Complete WordPress setup if this is the first deployment" >> $GITHUB_STEP_SUMMARY
        
        # Troubleshooting
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## 🔧 Troubleshooting" >> $GITHUB_STEP_SUMMARY
        echo "If services are not running:" >> $GITHUB_STEP_SUMMARY
        echo "1. Check ECS service logs in CloudWatch" >> $GITHUB_STEP_SUMMARY
        echo "2. Verify security group configurations" >> $GITHUB_STEP_SUMMARY
        echo "3. Ensure RDS database is accessible" >> $GITHUB_STEP_SUMMARY
        echo "4. Check ECR repository for latest images" >> $GITHUB_STEP_SUMMARY
  notify-on-failure:
    name: Notify on Failure
    needs: [terraform-apply, build-and-deploy, deploy-wordpress]
    runs-on: ubuntu-latest
    if: failure() && github.ref == 'refs/heads/main'
    
    steps:
    - name: Create Issue on Failure
      uses: actions/github-script@v7
      with:
        script: |
          const title = `🚨 Deployment Failed - ${new Date().toISOString().split('T')[0]}`;
          
          // Build failed jobs list
          let failedJobs = [];
          if ('${{ needs.terraform-apply.result }}' === 'failure') {
            failedJobs.push('❌ Terraform Apply');
          }
          if ('${{ needs.build-and-deploy.result }}' === 'failure') {
            failedJobs.push('❌ Build and Deploy GeoJSON Processor');
          }
          if ('${{ needs.deploy-wordpress.result }}' === 'failure') {
            failedJobs.push('❌ Deploy WordPress');
          }
          
          const body = `## Deployment Failure Report
          
          **Workflow Run**: [${context.runNumber}](${context.payload.repository.html_url}/actions/runs/${context.runId})
          **Branch**: ${context.ref}
          **Commit**: ${context.sha.substring(0, 7)}
          **Triggered by**: @${context.actor}
          
          ### Failed Jobs:
          ${failedJobs.join('\n')}
          
          ### Next Steps:
          1. Check the workflow logs for detailed error messages
          2. Verify AWS credentials and permissions
          3. Check for any infrastructure conflicts
          4. Review recent changes that might have caused the failure
          
          ### Useful Commands:
          \`\`\`bash
          # Check ECS services
          aws ecs describe-services --cluster geojson-processor-cluster --services geojson-processor-service wordpress-service
          
          # Check CloudWatch logs
          aws logs describe-log-groups --log-group-name-prefix "/ecs/"
          
          # Check Terraform state
          terraform show
          \`\`\`
          
          **Auto-generated by GitHub Actions**`;
